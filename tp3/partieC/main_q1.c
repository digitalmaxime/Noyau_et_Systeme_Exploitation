#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>

//var globale Nombre de Lecteurs 
int NBL = 0;

struct argumentThread { 
    int compteur;
    long unsigned int tid;
    sem_t* redact;
    sem_t* mutx;
    sem_t* tour;
};

void* acces_bd_ecriture(int id_boucle, int tid){
    return NULL ;
}

void* acces_bd_lecture(int id_boucle, int tid){
    return NULL ;
}

void threadCleaner(void* _args) {
    struct argumentThread* args = (struct argumentThread*) _args;
    //pthread_cancel(tid); pour possiblement annuler d'autre threads dependants
    // comment liberer les semaphores si ils sont pris??
    free(args);
}
void* wrapper_ecrivain (void* _args) {
    struct argumentThread* args = (struct argumentThread*) _args;
    pthread_cleanup_push(threadCleaner, args);
    args->tid = pthread_self(); 
    
    //controle acces a la BD
    sem_wait(args->tour);
    sem_wait(args->redact);
    sem_post(args->tour);
    acces_bd_ecriture(args->compteur, args->tid);
    printf("ECRIVAIN Numero du compter : %d, tid : %ld\n", args->compteur, args->tid);
    sem_post(args->redact);
    free(args);
    pthread_cleanup_pop(0);
    return NULL;
}

void* wrapper_lecteur (void* _args) {
    struct argumentThread* args = (struct argumentThread*) _args;
    args->tid = pthread_self(); 

    //controle acces a la BD
    sem_wait(args->tour);
    sem_wait(args->mutx);
    if (NBL == 0) {sem_wait(args->redact);}; // si ecrivain est la, on attend qu'il finisse
    sem_post(args->tour);
    NBL++; 
    sem_post(args->mutx);

    // code critique
    acces_bd_lecture(args->compteur, args->tid);
    printf("LECTEUR Numero du compter : %d, tid : %ld\n", args->compteur, args->tid);

    sem_wait(args->mutx);
    NBL--;
    if (NBL == 0) { sem_post(args->redact);}
    sem_post(args->mutx);

    free(args);
    return NULL;
}

sem_t* init_sem() {
    sem_t* semaphore = malloc(sizeof(sem_t));
    sem_init(semaphore, 0, 1);
    return semaphore;
}

void detruire_sem(sem_t* sem) {
    sem_destroy(sem);    
    free(sem);
}


int main() {

    sem_t* semaphore = init_sem();
    sem_t* mtx = init_sem();
    sem_t* tour = init_sem();

    pthread_t tids_ecrivains[10];
    pthread_t tids_lecteurs[10];

    //creation des threads ecrivains
    for (int i=0; i<10; i++) {
        struct argumentThread* arg = malloc(sizeof(struct argumentThread));
        arg->compteur = i;
        arg->redact = semaphore;
        arg->tour = tour; 
        pthread_create(&tids_ecrivains[i], NULL, wrapper_ecrivain, arg);
    }

    //creation des threads lecteurs
    for (int i=0; i<10; i++) {
        struct argumentThread* arg = malloc(sizeof(struct argumentThread));
        arg->compteur = i;
        arg->redact = semaphore;
        arg->mutx = mtx;
        arg->tour = tour;
        pthread_create(&tids_lecteurs[i], NULL, wrapper_lecteur, arg);
    }

    for (int i=0; i<10; i++) {
        pthread_join(tids_ecrivains[i], NULL);
    }
    for(int i=0; i<10; i++) {
        pthread_join(tids_lecteurs[i], NULL);
    }

    detruire_sem(semaphore);
    detruire_sem(mtx);
    detruire_sem(tour);
    
    return 0;
}